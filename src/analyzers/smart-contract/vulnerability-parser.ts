/**
 * Vulnerability Parser
 * Converts Slither detector results to standardized vulnerability objects
 */

import {
  SlitherDetectorResult,
  SlitherElement,
  SlitherSourceMapping,
  Vulnerability,
  SourceLocation,
  AnalysisSummary,
  SlitherMetadata,
  SlitherImpact,
  SlitherConfidence
} from './types';
import { logger } from '../../config/logger';

export class VulnerabilityParser {
  /**
   * Parse Slither detector results into vulnerability objects
   */
  static parseVulnerabilities(detectorResults: SlitherDetectorResult[]): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];

    if (!detectorResults) {
      logger.warn('No detector results provided to parseVulnerabilities');
      return vulnerabilities;
    }

    for (const result of detectorResults) {
      try {
        const vulnerability = this.parseDetectorResult(result);
        if (vulnerability) {
          vulnerabilities.push(vulnerability);
        }
      } catch (error) {
        logger.warn(`Failed to parse detector result`, {
          detector: result?.check || 'unknown',
          error: error instanceof Error ? error.message : 'Unknown error',
          result: JSON.stringify(result, null, 2)
        });
      }
    }

    return vulnerabilities;
  }

  /**
   * Parse a single detector result
   */
  private static parseDetectorResult(result: SlitherDetectorResult): Vulnerability | null {
    // Skip informational findings that don't represent security issues
    if (this.shouldSkipResult(result)) {
      return null;
    }

    const location = this.parseSourceLocation(result.elements);
    const impact = this.generateImpactDescription(result);
    const recommendation = this.generateRecommendation(result);

    return {
      detector: result.check,
      severity: result.impact,
      confidence: result.confidence,
      description: result.description,
      location,
      impact,
      recommendation,
      id: result.id,
      markdown: result.markdown
    };
  }

  /**
   * Extract source location from Slither elements
   */
  private static parseSourceLocation(elements: SlitherElement[]): SourceLocation {
    // Find the most relevant source location (prefer contracts over other elements)
    const relevantElement = elements.find(el => 
      el.type === 'contract' || 
      el.type === 'function' || 
      el.type === 'variable'
    ) || elements[0];

    if (!relevantElement?.source_mapping) {
      return {
        filename: 'unknown',
        startLine: 0,
        endLine: 0,
        startColumn: 0,
        endColumn: 0
      };
    }

    const mapping = relevantElement.source_mapping;
    const lines = mapping.lines || [];
    
    return {
      filename: mapping.filename_relative || mapping.filename_short || 'unknown',
      startLine: lines[0] || 0,
      endLine: lines[lines.length - 1] || lines[0] || 0,
      startColumn: mapping.starting_column || 0,
      endColumn: mapping.ending_column || 0
    };
  }

  /**
   * Generate impact description based on detector type
   */
  private static generateImpactDescription(result: SlitherDetectorResult): string {
    const detector = result.check;
    const impact = result.impact;

    const impactDescriptions: Record<string, string> = {
      'reentrancy-eth': 'Potential loss of funds through reentrancy attacks during Ether transfers',
      'reentrancy-no-eth': 'State inconsistency through reentrancy in state-changing functions',
      'reentrancy-benign': 'Minor reentrancy that may cause unexpected behavior',
      'timestamp': 'Block timestamp manipulation by miners could affect contract logic',
      'tx-origin': 'Use of tx.origin makes contract vulnerable to phishing attacks',
      'unchecked-transfer': 'Failed transfers may not be detected, leading to unexpected behavior',
      'uninitialized-storage': 'Uninitialized storage variables may contain unexpected values',
      'dangerous-delegatecall': 'Delegatecall to user-controlled addresses can lead to arbitrary code execution',
      'unchecked-lowlevel': 'Unchecked low-level calls may fail silently',
      'controlled-delegatecall': 'User-controlled delegatecall destination enables arbitrary code execution',
      'assembly': 'Inline assembly bypasses Solidity safety checks',
      'suicidal': 'Contract can be destroyed by unauthorized users',
      'arbitrary-send-eth': 'Ether can be sent to arbitrary addresses',
      'missing-zero-check': 'Missing zero address checks may lead to unexpected behavior',
      'locked-ether': 'Ether may become permanently locked in the contract',
      'tautology': 'Tautological conditions indicate potential logic errors',
      'boolean-cst': 'Boolean constants in conditions may indicate dead code',
      'incorrect-equality': 'Dangerous strict equality checks on floating point-like values',
      'divide-before-multiply': 'Division before multiplication may cause precision loss',
      'void-cst': 'Void constructor calls waste gas and may indicate errors'
    };

    const baseDescription = impactDescriptions[detector] || 
      `Potential security or code quality issue detected by ${detector}`;

    const severityContext = this.getSeverityContext(impact);
    
    return `${baseDescription}. ${severityContext}`;
  }

  /**
   * Get severity context description
   */
  private static getSeverityContext(impact: SlitherImpact): string {
    switch (impact) {
      case SlitherImpact.HIGH:
        return 'This issue could lead to significant financial loss or contract compromise.';
      case SlitherImpact.MEDIUM:
        return 'This issue could lead to unexpected behavior or potential exploits.';
      case SlitherImpact.LOW:
        return 'This issue represents a code quality concern or minor security risk.';
      case SlitherImpact.INFORMATIONAL:
        return 'This is an informational finding for code improvement.';
      default:
        return 'This issue requires review to determine its impact.';
    }
  }

  /**
   * Generate recommendations based on detector type
   */
  private static generateRecommendation(result: SlitherDetectorResult): string {
    const detector = result.check;

    const recommendations: Record<string, string> = {
      'reentrancy-eth': 'Use the Checks-Effects-Interactions pattern or implement reentrancy guards (ReentrancyGuard from OpenZeppelin)',
      'reentrancy-no-eth': 'Apply the Checks-Effects-Interactions pattern and consider using mutex locks',
      'reentrancy-benign': 'Review the function flow and consider adding reentrancy protection if needed',
      'timestamp': 'Avoid using block.timestamp for critical logic or use block numbers with appropriate tolerances',
      'tx-origin': 'Replace tx.origin with msg.sender and implement proper authorization checks',
      'unchecked-transfer': 'Check the return value of transfer calls or use SafeERC20 from OpenZeppelin',
      'uninitialized-storage': 'Initialize all storage variables explicitly in the constructor or at declaration',
      'dangerous-delegatecall': 'Validate delegatecall targets against a whitelist or remove delegatecall functionality',
      'unchecked-lowlevel': 'Check the return value of low-level calls and handle failures appropriately',
      'controlled-delegatecall': 'Remove user control over delegatecall targets or implement strict validation',
      'assembly': 'Review assembly code for safety and consider using Solidity alternatives where possible',
      'suicidal': 'Remove selfdestruct functionality or implement proper access controls',
      'arbitrary-send-eth': 'Implement proper recipient validation and consider using pull payment patterns',
      'missing-zero-check': 'Add require statements to check for zero addresses where appropriate',
      'locked-ether': 'Implement a withdrawal function or prevent Ether from being sent to the contract',
      'tautology': 'Review and fix the conditional logic to remove tautological conditions',
      'boolean-cst': 'Remove boolean constants from conditions or review the logic flow',
      'incorrect-equality': 'Use appropriate comparison operators and consider tolerance for floating-point-like comparisons',
      'divide-before-multiply': 'Reorder operations to multiply before dividing to preserve precision',
      'void-cst': 'Remove unnecessary constructor calls or ensure they serve a purpose'
    };

    return recommendations[detector] || 
      'Review the flagged code and consult Slither documentation for specific remediation guidance';
  }

  /**
   * Determine if a result should be skipped
   */
  private static shouldSkipResult(result: SlitherDetectorResult): boolean {
    // Skip certain informational detectors that don't represent security issues
    const skipDetectors = [
      'pragma',
      'solc-version',
      'naming-convention',
      'external-function',
      'public-mappings-nested'
    ];

    return skipDetectors.includes(result.check);
  }

  /**
   * Generate analysis summary from vulnerabilities
   */
  static generateSummary(
    vulnerabilities: Vulnerability[],
    executionTime: number,
    contractsAnalyzed: number = 1
  ): AnalysisSummary {
    const severityCounts = vulnerabilities.reduce(
      (counts, vuln) => {
        switch (vuln.severity) {
          case SlitherImpact.HIGH:
            counts.highSeverityCount++;
            break;
          case SlitherImpact.MEDIUM:
            counts.mediumSeverityCount++;
            break;
          case SlitherImpact.LOW:
            counts.lowSeverityCount++;
            break;
          case SlitherImpact.INFORMATIONAL:
            counts.informationalCount++;
            break;
        }
        return counts;
      },
      {
        highSeverityCount: 0,
        mediumSeverityCount: 0,
        lowSeverityCount: 0,
        informationalCount: 0
      }
    );

    return {
      totalVulnerabilities: vulnerabilities.length,
      ...severityCounts,
      executionTime,
      contractsAnalyzed
    };
  }

  /**
   * Generate metadata for the analysis
   */
  static generateMetadata(
    slitherVersion: string,
    configUsed: string,
    detectorCount: number,
    solidityVersion?: string
  ): SlitherMetadata {
    return {
      slitherVersion,
      ...(solidityVersion ? { solidityVersion } : {}),
      compilationSuccess: true, // We assume success if we got results
      analysisTimestamp: new Date(),
      configUsed,
      detectorCount
    };
  }
}
